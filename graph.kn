+class Graph()
	+var posX: float
	+var posY: float
	+var width: float
	+var height: float
	+var titleFont: draw@Font
	+var labelFont: draw@Font
	+var varFont: draw@Font
	+var fontColor: int
	+var title: []char
	+var labelX: []char
	+var labelY: []char
	+var labelSize: float
	+var axisColor: int
	
	*func ctor()
		do me.posX :: 50.0
		do me.posY :: 50.0
		do me.width :: 400.0
		do me.height :: 300.0
		do me.titleFont :: draw@makeFont(null, 14, false, false, true, 0.0)
		do me.labelFont :: draw@makeFont(null, 12, false, false, true, 0.0)
		do me.varFont :: draw@makeFont(null, 12, false, false, true, 0.0)
		do me.fontColor :: draw@black
		do me.title :: ""
		do me.labelX :: ""
		do me.labelY :: ""
		do me.labelSize :: 55.0
		do me.axisColor :: draw@black
	end func
	
	+func setPos(posX: float, posY: float, width: float, height: float)
		do me.posX :: posX
		do me.posY :: posY
		do me.width :: width
		do me.height :: height
	end func
	
	func drawAxis(scaleX: []float, scaleY: []float) {軸の描画, TODO:Scaleクラスで受け取る}
		do draw@line(me.posX + me.labelSize, me.posY, me.posX + me.labelSize, me.posY + me.height - me.labelSize, me.axisColor)
		do draw@line(me.posX + me.labelSize, me.posY, me.posX + me.width, me.posY, me.axisColor)
		do draw@line(me.posX + me.width, me.posY + me.height - me.labelSize, me.posX + me.labelSize, me.posY + me.height - me.labelSize, me.axisColor)
		do draw@line(me.posX + me.width, me.posY + me.height - me.labelSize, me.posX + me.width, me.posY, me.axisColor)
		do me.drawScale(scaleX, scaleY)
	end func
	
	func drawScale(scaleX: []float, scaleY: []float) {目盛りの表示，TODO:Scaleクラスで受け取る}
		{X軸の目盛り描画}
		var scaleMinX: float :: scaleX[0]
		var scaleMaxX: float :: scaleX[1]
		var intervalX: float :: scaleX[2]
		var nX: int :: scaleX[3] $ int
		var drawBaseX: float :: me.posX + me.labelSize
		var drawMagnifyX: float :: (me.width - me.labelSize) / (scaleMaxX - scaleMinX)
		for i(0, nX)
			var drawPointX: float :: intervalX * i $ float * drawMagnifyX + drawBaseX
			var drawPointY: float :: me.posY + me.height - me.labelSize
			do draw@line(drawPointX, drawPointY, drawPointX, drawPointY - 10.0, me.axisColor)
			do me.varFont.draw(drawPointX, drawPointY, (scaleMinX + intervalX * i $ float).toStr(), me.axisColor)
		end for
		{Y軸の目盛り描画}
		var scaleMinY: float :: scaleY[0]
		var scaleMaxY: float :: scaleY[1]
		var intervalY: float :: scaleY[2]
		var nY: int :: scaleY[3] $ int
		var drawBaseY: float :: me.posY + me.height - me.labelSize
		var drawMagnifyY: float :: (me.height - me.labelSize) / (scaleMaxY - scaleMinY)
		for i(0, nY)
			var drawPointX: float :: me.posX + me.labelSize
			var drawPointY: float :: drawBaseY - intervalY * i $ float * drawMagnifyY
			do draw@line(drawPointX, drawPointY, drawPointX + 10.0, drawPointY, me.axisColor)
			var str: []char :: (scaleMinY + intervalY * i $ float).toStr()
			do me.varFont.draw(drawPointX - (^str * 10) $ float - 5.0, drawPointY - 10.0, str, me.axisColor) {TODO:他のFontサイズでもきれいに描画できるようにする}
		end for
	end func
	
	{目盛りの計算}
	func autoScale(min: float, max: float): []float {[0]:目盛りの最小値,[1]:目盛りの最大値,[2]:目盛りの間隔,[3]:分割数，TODO:Scaleクラスで返す}
		var interval: float :: (max - min) / 5.0 {間隔の目安}
		var shift: int :: 0
		{間隔を1以上の数にする}
		while(interval < 1.0)
			do interval :* 10.0
			do shift :+ 1
		end while
		{間隔をきりの良い数字にする}
		var intervalInt: int :: interval $ int
		do intervalInt :: lib@round(intervalInt $ float, -1 * (^intervalInt.toStr() - 1)) $ int
		switch(intervalInt.toStr()[0])
		case '6', '7', '8', '9'
			do intervalInt :: 10 * 10 ^ (^intervalInt.toStr() - 1)
		case '3', '4', '5'
			do intervalInt :: 5 * 10 ^ (^intervalInt.toStr() - 1)
		end switch
		
		do interval :: intervalInt $ float * 10.0 ^ (-shift $ float)
		var scaleMax: float :: interval * lib@ceil(max / interval)
		var nextScale: float :: scaleMax - interval
		var n: int :: lib@ceil((scaleMax - min) / interval) $ int {軸の分割数}
		var scaleMin: float :: scaleMax - interval * n $ float
		ret[scaleMin, scaleMax, interval, n $ float]
	end func
	
	func drawLabel() {TODO:縦軸のラベルの表示}
		do me.labelFont.draw(me.posX + me.labelSize + (me.width - me.labelSize) / 2.0 - (^me.labelX) $ float * 5.0, me.posY + me.height - 0.65 * me.labelSize, me.labelX, me.fontColor)
	end func
	
	func drawTitle()
		do me.titleFont.draw(me.posX + me.width / 2.0 - (^me.title) $ float * 8.0, me.posY + me.height, me.title, me.fontColor)
	end func
	
	+func plot(x: []float, y: []float, color: int) {折れ線グラフ}
		var n: int :: ^y
		var scaleX: []float :: me.autoScale(x.min(), x.max())
		var minX: float :: scaleX[0]
		var maxX: float :: scaleX[1]
		var scaleY: []float :: me.autoScale(y.min(), y.max())
		var minY: float :: scaleY[0]
		var maxY: float :: scaleY[1]
		do me.drawAxis(scaleX, scaleY)
		var baseX: float :: me.posX + me.labelSize
		var baseY: float :: me.posY + me.height - me.labelSize
		var magnifyX: float :: (me.width - me.labelSize) / (maxX - minX)
		var magnifyY: float :: (me.height - me.labelSize) / (maxY - minY)
		for i(0, n - 2)
			do draw@line((x[i] - minX) * magnifyX + baseX, (minY - y[i]) * magnifyY + baseY, (x[i + 1] - minX) * magnifyX + baseX, (minY - y[i + 1]) * magnifyY + baseY, color)
		end for
		do me.drawLabel()
		do me.drawTitle()
	end func
	
	+func scatterPlot(x: []float, y: []float, size: float, color: int) {散布図}
		var n: int :: ^y
		var scaleX: []float :: me.autoScale(x.min(), x.max())
		var minX: float :: scaleX[0]
		var maxX: float :: scaleX[1]
		var scaleY: []float :: me.autoScale(y.min(), y.max())
		var minY: float :: scaleY[0]
		var maxY: float :: scaleY[1]
		do me.drawAxis(scaleX, scaleY)
		var baseX: float :: me.posX + me.labelSize
		var baseY: float :: me.posY + me.height - me.labelSize
		var magnifyX: float :: (me.width - me.labelSize) / (maxX - minX)
		var magnifyY: float :: (me.height - me.labelSize) / (maxY - minY)
		for i(0, n - 1)
			do draw@circle((x[i] - minX) * magnifyX + baseX, (minY - y[i]) * magnifyY + baseY, size, size, color)
		end for
		do me.drawLabel()
		do me.drawTitle()
	end func
	
	+func barChart(label: [][]char, value: float, color: int) {棒グラフ}
		
	end func
	
	+func circleChart(label: [][]char, value: []float, color: []int) {円グラフ}
		
	end func
end class
