+class Graph()
	+var posX: float
	+var posY: float
	+var width: float
	+var height: float
	+var titleFont: draw@Font
	+var labelFont: draw@Font
	+var varFont: draw@Font
	+var fontColor: int
	+var title: []char
	+var labelX: []char
	+var labelY: []char
	+var labelSize: float
	+var axisColor: int
	+var scaleX: @Scale
	+var scaleY: @Scale
	
	*func ctor()
		do me.posX :: 50.0
		do me.posY :: 50.0
		do me.width :: 400.0
		do me.height :: 300.0
		do me.titleFont :: draw@makeFont(null, 14, false, false, true, 0.0)
		do me.labelFont :: draw@makeFont(null, 12, false, false, true, 0.0)
		do me.varFont :: draw@makeFont(null, 12, false, false, true, 0.0)
		do me.fontColor :: draw@black
		do me.title :: ""
		do me.labelX :: ""
		do me.labelY :: ""
		do me.labelSize :: 55.0
		do me.axisColor :: draw@black
	end func
	
	+func setPos(posX: float, posY: float, width: float, height: float)
		do me.posX :: posX
		do me.posY :: posY
		do me.width :: width
		do me.height :: height
	end func
	
	func drawAxis(scaleX: @Scale, scaleY: @Scale) {軸の描画, TODO:Scaleクラスで受け取る}
		do draw@line(me.posX + me.labelSize, me.posY, me.posX + me.labelSize, me.posY + me.height - me.labelSize, me.axisColor)
		do draw@line(me.posX + me.labelSize, me.posY, me.posX + me.width, me.posY, me.axisColor)
		do draw@line(me.posX + me.width, me.posY + me.height - me.labelSize, me.posX + me.labelSize, me.posY + me.height - me.labelSize, me.axisColor)
		do draw@line(me.posX + me.width, me.posY + me.height - me.labelSize, me.posX + me.width, me.posY, me.axisColor)
		do me.drawScale(scaleX, scaleY)
	end func
	
	func drawScale(scaleX: @Scale, scaleY: @Scale) {目盛りの表示，TODO:Scaleクラスで受け取る}
		{X軸の目盛り描画}
		var nX: int :: ((scaleX.max - scaleX.min) / scaleX.interval) $ int
		var drawBaseX: float :: me.posX + me.labelSize
		var drawMagnifyX: float :: (me.width - me.labelSize) / (scaleX.max - scaleX.min)
		for i(0, nX)
			var drawPointX: float :: scaleX.interval * i $ float * drawMagnifyX + drawBaseX
			var drawPointY: float :: me.posY + me.height - me.labelSize
			do draw@line(drawPointX, drawPointY, drawPointX, drawPointY - 10.0, me.axisColor)
			do me.varFont.draw(drawPointX, drawPointY, (scaleX.min + scaleX.interval * i $ float).toStr(), me.axisColor)
		end for
		{Y軸の目盛り描画}
		var nY: int :: ((scaleY.max - scaleY.min) / scaleY.interval) $ int
		var drawBaseY: float :: me.posY + me.height - me.labelSize
		var drawMagnifyY: float :: (me.height - me.labelSize) / (scaleY.max - scaleY.min)
		for i(0, nY)
			var drawPointX: float :: me.posX + me.labelSize
			var drawPointY: float :: drawBaseY - scaleY.interval * i $ float * drawMagnifyY
			do draw@line(drawPointX, drawPointY, drawPointX + 10.0, drawPointY, me.axisColor)
			var str: []char :: (scaleY.min + scaleY.interval * i $ float).toStr()
			do me.varFont.draw(drawPointX - (^str * 10) $ float - 5.0, drawPointY - 10.0, str, me.axisColor) {TODO:他のFontサイズでもきれいに描画できるようにする}
		end for
	end func
	
	{目盛りの計算}
	func autoScale(min: float, max: float): @Scale
		var interval: float :: (max - min) / 5.0 {間隔の目安}
		var shift: int :: 0
		{間隔を1以上の数にする}
		while(interval < 1.0)
			do interval :* 10.0
			do shift :+ 1
		end while
		{間隔をきりの良い数字にする}
		var intervalInt: int :: interval $ int
		do intervalInt :: lib@round(intervalInt $ float, -1 * (^intervalInt.toStr() - 1)) $ int
		switch(intervalInt.toStr()[0])
		case '6', '7', '8', '9'
			do intervalInt :: 10 * 10 ^ (^intervalInt.toStr() - 1)
		case '3', '4', '5'
			do intervalInt :: 5 * 10 ^ (^intervalInt.toStr() - 1)
		end switch
		
		var scale: @Scale :: #@Scale
		do scale.interval :: intervalInt $ float * 10.0 ^ (-shift $ float)
		do scale.max :: scale.interval * lib@ceil(max / scale.interval)
		var n: int :: lib@ceil((scale.max - min) / scale.interval) $ int {軸の分割数}
		do scale.min :: scale.max - scale.interval * n $ float
		ret scale
	end func
	
	func drawLabel() {TODO:縦軸のラベルの表示}
		do me.labelFont.draw(me.posX + me.labelSize + (me.width - me.labelSize) / 2.0 - (^me.labelX) $ float * 5.0, me.posY + me.height - 0.65 * me.labelSize, me.labelX, me.fontColor)
	end func
	
	func drawTitle()
		do me.titleFont.draw(me.posX + me.width / 2.0 - (^me.title) $ float * 8.0, me.posY + me.height, me.title, me.fontColor)
	end func
	
	+func plot(x: []float, y: []float, color: int) {折れ線グラフ}
		var n: int :: ^y
		if(me.scaleX =& null)
			do me.scaleX :: me.autoScale(x.min(), x.max())
		end if
		if(me.scaleY =& null)
			do me.scaleY :: me.autoScale(y.min(), y.max())
		end if
		do me.drawAxis(me.scaleX, me.scaleY)
		var baseX: float :: me.posX + me.labelSize
		var baseY: float :: me.posY + me.height - me.labelSize
		var magnifyX: float :: (me.width - me.labelSize) / (me.scaleX.max - me.scaleX.min)
		var magnifyY: float :: (me.height - me.labelSize) / (me.scaleY.max - me.scaleY.min)
		for i(0, n - 2)
			do draw@line((x[i] - me.scaleX.min) * magnifyX + baseX, (me.scaleY.min - y[i]) * magnifyY + baseY, (x[i + 1] - me.scaleX.min) * magnifyX + baseX, (me.scaleY.min - y[i + 1]) * magnifyY + baseY, color)
		end for
		do me.drawLabel()
		do me.drawTitle()
	end func
	
	+func scatterPlot(x: []float, y: []float, size: float, color: int) {散布図}
		var n: int :: ^y
		if(me.scaleX =& null)
			do me.scaleX :: me.autoScale(x.min(), x.max())
		end if
		if(me.scaleY =& null)
			do me.scaleY :: me.autoScale(y.min(), y.max())
		end if
		do me.drawAxis(me.scaleX, me.scaleY)
		var baseX: float :: me.posX + me.labelSize
		var baseY: float :: me.posY + me.height - me.labelSize
		var magnifyX: float :: (me.width - me.labelSize) / (me.scaleX.max - me.scaleX.min)
		var magnifyY: float :: (me.height - me.labelSize) / (me.scaleY.max - me.scaleY.min)
		for i(0, n - 1)
			do draw@circle((x[i] - me.scaleX.min) * magnifyX + baseX, (me.scaleY.min - y[i]) * magnifyY + baseY, size, size, color)
		end for
		do me.drawLabel()
		do me.drawTitle()
	end func
end class

+class Scale()
	+var min: float
	+var max: float
	+var interval: float
	
	+func setScale(min: float, max: float, interval: float)
		assert min < max
		assert !(interval = 0.0)
		assert((max - min) / interval) % 1.0 = 0.0
		do me.min :: min
		do me.max :: max
		do me.interval :: interval
	end func
end class
